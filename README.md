### goit-algo-hw-06
# Висновки по завданням
## Завдання №1 
Я створив граф, що моделює (вигадану) просту соціальну мережу. Ось деякі ключові характеристики цієї мережі:

- Кількість вузлів (людей у мережі): 15

- Кількість ребер (зв'язків між людьми): 24

- Середній ступінь вершини (середня кількість зв'язків на одну людину): 3.2

Цей граф є прикладом простої соціальної мережі, де кожен вузол представляє особу, а ребра - взаємозв'язки між ними. Візуалізація графа допомагає зрозуміти структуру мережі та зв'язки між її членами.

# Завдання №2

- Шлях, знайдений за допомогою BFS (пошуку в ширину): \[1, 2, 4, 6, 8, 9, 11, 13, 15\]
- Шлях, знайдений за допомогою DFS (пошуку в глибину): \[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 11, 13, 14, 15\]

1. **BFS (Пошук в ширину):** Цей алгоритм рухається по графу шар за шаром. Він спочатку відвідує всі вершини, які знаходяться на одній відстані від початкової точки, перш ніж переходити до вершин наступного шару. Це призводить до знаходження найкоротшого шляху в невагових графах, як у нашому випадку.

2. **DFS (Пошук в глибину):** Навпаки, DFS занурюється в глибину графа, намагаючись йти якомога далі від початкової точки, перш ніж повертатися назад. Це може призводити до відвідування більшої кількості вершин і знаходження довших шляхів, як ми бачимо в результаті.

Тому, хоча обидва алгоритми знаходять шлях між заданими точками, шлях, знайдений за допомогою BFS, є найкоротшим, тоді як шлях DFS може бути довшим та менш прямим.

# Завдання №3
Я використав random (вага ребра випадково обирається від 1 до 10) для генераціїї ваги в ребрах графу для соціальних відносин. Ці ваги можуть бути інтерпретовані як вартість або зусилля для переходу від одного вузла (людини) до іншого у соціальній мережі.  
Я використав алгоритм Дейкстри для знаходження найкоротших шляхів від 1  до останої 15. 
Ці шляхи визначаються на основі найменших загальних ваг ребер між вузлами. Алгоритм Дейкстри ефективно знаходить найкоротший шлях в графі, де вага кожного ребра представляє вартість переходу від однієї вершини до іншої

Ось найкоротші шлях в цьому графі: 1, 3, 4, 6, 8, 10, 12, 13, 15 (але він кожен раз буде генеруватись по різному)